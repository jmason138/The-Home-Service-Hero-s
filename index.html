<script>
    // ... (Keep assets and state the same)

    function spawnLoop() {
        if (!state.active || state.challenges >= 20) return;
        
        const rand = Math.random();
        if(rand > 0.7) {
            // SCAM AD - Lowered to 390 so it's a real threat to your head
            // Width increased to 220 to make it a longer "duck"
            obstacles.push({ x: 850, y: 390, w: 220, h: 100, type: 'scam' });
        } else {
            // GROUND OBSTACLES
            const types = ['van', 'cone', 'crack', 'barricade', 'lowbid'];
            const type = types[Math.floor(Math.random() * types.length)];
            let w = 80, h = 80, y = 455;
            
            if(type === 'van') { w = 220; h = 140; y = 395; } 
            if(type === 'crack') { w = 110; h = 30; y = 505; }

            obstacles.push({ x: 850, y: y, w: w, h: h, type: type });
        }

        // Spawn Items
        if(Math.random() > 0.6) {
            const itType = Math.random() > 0.5 ? 'energy' : 'coffee';
            items.push({ x: 900, y: 300, w: 50, h: 50, type: itType });
        }

        state.challenges++;
        document.getElementById('count').innerText = state.challenges;
        setTimeout(spawnLoop, 1400 + Math.random() * 1000);
    }

    function checkCollision(p, o) {
        // PRO HITBOX: When ducking, the height is reduced by 70%
        let pH = p.isDucking && p.grounded ? p.h * 0.3 : p.h;
        let pY = p.isDucking && p.grounded ? p.y + (p.h * 0.7) : p.y;
        
        // PADDING: Makes the collision feel more fair
        const padding = 20; 
        
        return p.x + padding < o.x + o.w && 
               p.x + p.w - padding > o.x && 
               pY + padding < o.y + o.h && 
               pY + pH - padding > o.y;
    }

    function draw() {
        ctx.clearRect(0, 0, 800, 600);
        if(assets.bg.complete) ctx.drawImage(assets.bg, 0, 0, 800, 600);
        if (state.challenges >= 20 && assets.house.complete) ctx.drawImage(assets.house, state.houseX, 200, 350, 350);

        const charKey = `${state.job}_${state.isGold ? 'gold' : 'normal'}`;
        
        // VISUAL DUCK: Shrink the character image when S is held
        let drawH = player.h;
        let drawY = player.y;

        if(player.isDucking && player.grounded) {
            drawH = player.h * 0.4; // Squatting visual
            drawY = player.y + (player.h * 0.6); 
        }

        if(assets[charKey] && assets[charKey].complete) {
            ctx.drawImage(assets[charKey], player.x, drawY, player.w, drawH);
        }

        // Draw Obstacles
        obstacles.forEach(o => {
            if(assets[o.type] && assets[o.type].complete) {
                ctx.drawImage(assets[o.type], o.x, o.y, o.w, o.h);
            }
        });

        // Draw Items
        items.forEach(it => {
            if(assets[it.type] && assets[it.type].complete) {
                ctx.drawImage(assets[it.type], it.x, it.y, it.w, it.h);
            }
        });
    }
</script>
